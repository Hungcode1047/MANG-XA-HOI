# -*- coding: utf-8 -*-
"""Lab03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w-Da3sFxh7W19juBODVuvqUwMYfoNhIQ

# Yêu cầu:

1. Viết lại bài Lab03.02 thành class, xây dựng pipeline áp dụng cho đồ thị mạng xã hội bất kỳ.
2. Giới thiệu tổng quan về thuật toán louvain
3. Tóm tắt tổng quan các chỉ số đánh giá việc phát hiện cộng đồn
"""

import networkx as nx
import matplotlib.pyplot as plt
from networkx.algorithms import community
import numpy as np
from networkx.algorithms import cuts
import pandas as pd

# Load Les Misérables Graph
G = nx.les_miserables_graph()

# Add function to calculate metrics
def calculate_metrics(G, communities):
    metrics = {
        'num_communities': len(communities),
        'modularity': community.modularity(G, communities),
        'conductance': np.mean([cuts.conductance(G, c) for c in communities]),
        'normalized_cut': np.mean([cuts.normalized_cut_size(G, c) for c in communities])
    }
    return metrics

def create_community_node_colors(graph, communities):
    node_colors = []
    for node in graph:
        for idx, comm in enumerate(communities):
            if node in comm:
                node_colors.append(plt.cm.jet(idx / len(communities)))
                break
    return node_colors

def visualize_communities(graph, communities, title, ax):
    node_colors = create_community_node_colors(graph, communities)
    pos = nx.spring_layout(graph, k=0.3, iterations=50, seed=2)
    modularity = community.modularity(graph, communities)

    ax.set_title(f"{title}\n{len(communities)} communities (Modularity: {modularity:.3f})")
    nx.draw(graph, pos=pos, node_size=500, node_color=node_colors,
            with_labels=True, font_size=8, ax=ax)

# Community detection algorithms
# Girvan-Newman
girvan_newman_generator = community.girvan_newman(G)
girvan_newman_partition = max(girvan_newman_generator, key=lambda partition: community.modularity(G, partition))

# Label Propagation
label_propagation_partition = community.label_propagation_communities(G)

# Louvain (alternative implementation)
louvain_partition = list(community.louvain_communities(G))

# Plot communities for Les Misérables
fig, axes = plt.subplots(1, 3, figsize=(20, 6))

visualize_communities(G, louvain_partition, "Louvain", axes[0])
visualize_communities(G, label_propagation_partition, "Label Propagation", axes[1])
visualize_communities(G, girvan_newman_partition, "Girvan-Newman", axes[2])

# Compare metrics
metrics_data = []
algorithms = ["Louvain", "Label Propagation", "Girvan-Newman"]

for partition, algorithm in zip([louvain_partition, label_propagation_partition, girvan_newman_partition], algorithms):
    metrics = calculate_metrics(G, partition)
    metrics_data.append({
        'Algorithm': algorithm,
        'Num Communities': metrics['num_communities'],
        'Modularity': metrics['modularity'],
        'Conductance': metrics['conductance'],
        'Normalized Cut': metrics['normalized_cut']
    })

metrics_df = pd.DataFrame(metrics_data)

# Plot metrics comparison
fig, axes = plt.subplots(1, 2, figsize=(18, 7))

# Bar chart for comparing 'Num Communities' between algorithms
axes[0].bar(metrics_df['Algorithm'], metrics_df['Num Communities'], color="#8E44AD")
axes[0].set_title("Num Communities Comparison")
axes[0].set_xlabel("Algorithm")
axes[0].set_ylabel("Num Communities")

# Bar chart for comparing Modularity, Conductance, and Normalized Cut for each algorithm
x = np.arange(len(metrics_df['Algorithm']))  # X positions for each algorithm
bar_width = 0.2

axes[1].bar(x - bar_width, metrics_df['Modularity'], width=bar_width, label='Modularity', color="#F2D140")
axes[1].bar(x, metrics_df['Conductance'], width=bar_width, label='Conductance', color="#FF6347")
axes[1].bar(x + bar_width, metrics_df['Normalized Cut'], width=bar_width, label='Normalized Cut', color="#48C9B0")

axes[1].set_title("Comparison of Metrics")
axes[1].set_xlabel("Algorithm")
axes[1].set_ylabel("Value")
axes[1].set_xticks(x)
axes[1].set_xticklabels(metrics_df['Algorithm'])
axes[1].legend()

plt.tight_layout()
plt.show()

# Visualize Louvain communities with larger nodes and labels
def visualize_louvain_large(graph, communities):
    pos = nx.spring_layout(graph, seed=42)  # Position nodes
    colors = plt.cm.tab20c(range(len(communities)))  # Generate distinct colors

    plt.figure(figsize=(14, 10))  # Larger figure
    for idx, community in enumerate(communities):
        nx.draw_networkx_nodes(
            graph, pos,
            nodelist=community,
            node_color=[colors[idx]],
            label=f'Community {idx+1}',
            node_size=300  # Larger nodes
        )
    nx.draw_networkx_edges(graph, pos, alpha=0.5)  # Draw edges with transparency
    nx.draw_networkx_labels(graph, pos, font_size=10, font_color="black")  # Larger labels
    plt.title(f'Louvain Communities\nModularity: {modularity:.3f}', fontsize=16)  # Larger title
    plt.legend(title="Communities", loc="best", fontsize=10)  # Legend adjustment
    plt.axis("off")
    plt.show()

visualize_louvain_large(G, louvain_partition)

from IPython.display import Markdown, display

def louvain_intro():
    content = """
    # **Tổng quan về thuật toán Louvain**

    Thuật toán Louvain là một phương pháp phổ biến và hiệu quả cao để phát hiện các **cộng đồng** (communities) trong đồ thị. Được giới thiệu bởi Blondel và cộng sự năm 2008, thuật toán này được đặt theo tên một trường đại học ở Bỉ, nơi các tác giả nghiên cứu.

    ## **Mục tiêu chính**
    Thuật toán Louvain tìm cách tối đa hóa **modularity**, một chỉ số đo lường chất lượng của các phân hoạch cộng đồng trong đồ thị. Modularity phản ánh mức độ mà các cạnh bên trong một cộng đồng dày đặc hơn so với các cạnh giữa các cộng đồng khác nhau.

    ## **Nguyên lý hoạt động**
    Thuật toán Louvain được thực hiện theo hai bước chính:

    1. **Tối ưu hóa cục bộ**:
       - Mỗi nút trong đồ thị ban đầu được xem là một cộng đồng riêng lẻ.
       - Thuật toán duyệt qua từng nút, di chuyển nút đó sang cộng đồng của nút lân cận nếu việc di chuyển làm tăng modularity.
       - Quá trình này lặp lại cho đến khi không có thay đổi nào làm tăng modularity.

    2. **Tạo đồ thị gộp (aggregation)**:
       - Một đồ thị mới được tạo, trong đó mỗi cộng đồng tìm được trở thành một "siêu nút".
       - Các cạnh giữa các cộng đồng được tính dựa trên tổng trọng số của các cạnh giữa các nút thuộc hai cộng đồng ban đầu.

    Quá trình kết thúc khi không còn cải thiện modularity đáng kể.

    ## **Đặc điểm nổi bật**
    - **Hiệu quả tính toán cao**:
      Louvain có thể xử lý đồ thị lớn, hàng triệu nút, nhờ thiết kế phân cấp và tính cục bộ trong các bước tối ưu.

    - **Phân cấp cộng đồng**:
      Thuật toán không chỉ tìm được một cấp độ cộng đồng, mà còn xây dựng một cấu trúc phân cấp, giúp chúng ta quan sát mối quan hệ giữa các cộng đồng lớn và nhỏ.

    - **Ứng dụng rộng rãi**:
      Louvain được sử dụng trong nhiều lĩnh vực như mạng xã hội, sinh học, mạng viễn thông, và các hệ thống khuyến nghị.

    ## **Ưu và nhược điểm**
    **Ưu điểm**:
    - Tốc độ nhanh và khả năng mở rộng tốt.
    - Có thể áp dụng cho đồ thị không trọng số và có trọng số.
    - Phân cấp giúp hiểu sâu hơn về cấu trúc mạng.

    **Nhược điểm**:
    - Có thể bị kẹt trong cực trị cục bộ của modularity.
    - Không hoạt động tốt với đồ thị rất thưa hoặc đồ thị không có cấu trúc cộng đồng rõ ràng.
    - Kết quả phụ thuộc vào cách khởi tạo ban đầu.

    ## **Tài liệu tham khảo**
    1. Blondel, V. D., Guillaume, J. L., Lambiotte, R., & Lefebvre, E. (2008). *Fast unfolding of communities in large networks*. Journal of Statistical Mechanics: Theory and Experiment.
    2. Các công cụ như **NetworkX** hoặc **igraph** cung cấp triển khai Louvain.
    """
    display(Markdown(content))

# Gọi hàm để hiển thị note
louvain_intro()